### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨ + ä½è¿ç®—

å¯¹äºŽæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªé•¿åº¦ä¸º $26$ çš„äºŒè¿›åˆ¶æ•°ï¼Œå…¶ä¸­ç¬¬ $i$ ä½ä¸º $1$ è¡¨ç¤ºè¯¥å­—ç¬¦ä¸²ä¸­åŒ…å«ç¬¬ $i$ ä¸ªå­—æ¯ã€‚

å¦‚æžœä¸¤ä¸ªå­—ç¬¦ä¸²åŒ…å«ç›¸åŒçš„å­—æ¯ï¼Œåˆ™å®ƒä»¬çš„äºŒè¿›åˆ¶æ•°æ˜¯ç›¸åŒçš„ï¼Œå› æ­¤ï¼Œå¯¹äºŽæ¯ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡å…¶äºŒè¿›åˆ¶æ•°å‡ºçŽ°çš„æ¬¡æ•°ï¼Œæ¯ä¸€æ¬¡ç´¯åŠ åˆ°ç­”æ¡ˆä¸­ï¼Œå†å°†å…¶äºŒè¿›åˆ¶æ•°å‡ºçŽ°çš„æ¬¡æ•°åŠ  $1$ã€‚

* [sol1-Python3]

```python
class Solution:
    def similarPairs(self, words: List[str]) -> int:
        ans = 0
        cnt = Counter()
        for s in words:
            x = 0
            for c in map(ord, s):
                x |= 1 << (c - ord("a"))
            ans += cnt[x]
            cnt[x] += 1
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int similarPairs(String[] words) {
        int ans = 0;
        Map<Integer, Integer> cnt = new HashMap<>();
        for (var s : words) {
            int x = 0;
            for (char c : s.toCharArray()) {
                x |= 1 << (c - 'a');
            }
            ans += cnt.merge(x, 1, Integer::sum) - 1;
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int similarPairs(vector<string>& words) {
        int ans = 0;
        unordered_map<int, int> cnt;
        for (const auto& s : words) {
            int x = 0;
            for (auto& c : s) {
                x |= 1 << (c - 'a');
            }
            ans += cnt[x]++;
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func similarPairs(words []string) (ans int) {
	cnt := map[int]int{}
	for _, s := range words {
		x := 0
		for _, c := range s {
			x |= 1 << (c - 'a')
		}
		ans += cnt[x]
		cnt[x]++
	}
	return
}
```

* [sol1-TypeScript]

```ts
function similarPairs(words: string[]): number {
    let ans = 0;
    const cnt = new Map<number, number>();
    for (const s of words) {
        let x = 0;
        for (const c of s) {
            x |= 1 << (c.charCodeAt(0) - 97);
        }
        ans += cnt.get(x) || 0;
        cnt.set(x, (cnt.get(x) || 0) + 1);
    }
    return ans;
}
```

* [sol1-Rust]

```rust
use std::collections::HashMap;

impl Solution {
    pub fn similar_pairs(words: Vec<String>) -> i32 {
        let mut ans = 0;
        let mut cnt: HashMap<i32, i32> = HashMap::new();
        for s in words {
            let mut x = 0;
            for c in s.chars() {
                x |= 1 << ((c as u8) - b'a');
            }
            ans += cnt.get(&x).unwrap_or(&0);
            *cnt.entry(x).or_insert(0) += 1;
        }
        ans
    }
}
```

æ—¶é—´å¤æ‚åº¦ $O(L)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $L$ æ˜¯æ‰€æœ‰å­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹å’Œï¼Œè€Œ $n$ æ˜¯å­—ç¬¦ä¸²çš„æ•°é‡ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
